/**
 * TypeScript wrapper generator
 * Generates typed wrappers for MCP tools
 */

import * as fs from 'fs';
import * as path from 'path';
import { SchemaConverter, generateToolHash, toPascalCase, toCamelCase } from './schema-converter';
import { ToolDefinition } from '../types';

const AUTO_GEN_START = '// AUTO-GENERATED BY mcp-codegen v1.0.1';
const AUTO_GEN_END = '// END AUTO-GENERATED';
const USER_EDITABLE_COMMENT = '\n/* USER-EDITABLE AREA BELOW */\n';

export interface WrapperOptions {
  serverName: string;
  tool: ToolDefinition;
  outputDir: string;
  runtimePackage: string;
}

export class WrapperGenerator {
  private converter = new SchemaConverter();

  /**
   * Generate wrapper for a single tool
   */
  async generateWrapper(options: WrapperOptions): Promise<string> {
    const { serverName, tool, outputDir, runtimePackage } = options;

    const functionName = toCamelCase(tool.name);
    const paramsInterface = toPascalCase(tool.name) + 'Params';
    const resultInterface = toPascalCase(tool.name) + 'Result';

    // Convert schemas
    const paramsConversion = this.converter.convert(
      tool.inputSchema || {},
      paramsInterface
    );
    const resultConversion = this.converter.convert(
      tool.outputSchema || {},
      resultInterface
    );

    // Generate hash for change detection
    const hash = generateToolHash(tool);

    // Build wrapper content
    const autoGenerated = this.buildAutoGeneratedSection({
      hash,
      runtimePackage,
      paramsInterface,
      resultInterface,
      paramsType: paramsConversion.typeDefinition,
      resultType: resultConversion.typeDefinition,
      functionName,
      toolName: tool.name,
      serverName,
      description: tool.description || '',
      warnings: [...paramsConversion.warnings, ...resultConversion.warnings],
    });

    // Check if file exists and preserve user-editable section
    const outputPath = path.join(outputDir, serverName, `${tool.name}.ts`);
    let userSection = '';

    if (fs.existsSync(outputPath)) {
      const existing = fs.readFileSync(outputPath, 'utf-8');
      const existingHash = this.extractHash(existing);

      // Only preserve user section if hash matches
      if (existingHash === hash) {
        userSection = this.extractUserSection(existing);
      }
    }

    const fullContent = autoGenerated + USER_EDITABLE_COMMENT + userSection;

    // Write file
    this.ensureDir(path.dirname(outputPath));
    fs.writeFileSync(outputPath, fullContent, 'utf-8');

    return outputPath;
  }

  private buildAutoGeneratedSection(params: {
    hash: string;
    runtimePackage: string;
    paramsInterface: string;
    resultInterface: string;
    paramsType: string;
    resultType: string;
    functionName: string;
    toolName: string;
    serverName: string;
    description: string;
    warnings: string[];
  }): string {
    const {
      hash,
      runtimePackage,
      paramsInterface,
      resultInterface,
      paramsType,
      resultType,
      functionName,
      toolName,
      serverName,
      description,
      warnings,
    } = params;

    const warningComments = warnings.length > 0
      ? '\n// WARNINGS:\n' + warnings.map(w => `// - ${w}`).join('\n') + '\n'
      : '';

    return `${AUTO_GEN_START}
// DO NOT EDIT BELOW THIS LINE
// hash: ${hash}
${warningComments}
import { callMCPToolTyped } from "${runtimePackage}";

${paramsType}

${resultType}

export const toolMeta = {
  server: "${serverName}",
  name: "${toolName}",
  description: ${JSON.stringify(description)}
};

/**
 * ${description || toolName}
 */
export async function ${functionName}(params: ${paramsInterface}): Promise<${resultInterface}> {
  return callMCPToolTyped<${paramsInterface}, ${resultInterface}>("${serverName}__${toolName}", params);
}

${AUTO_GEN_END}
`;
  }

  private extractHash(content: string): string | null {
    const match = content.match(/\/\/ hash: ([a-f0-9]+)/);
    return match ? match[1] : null;
  }

  private extractUserSection(content: string): string {
    const endIndex = content.indexOf(AUTO_GEN_END);
    if (endIndex === -1) return '';

    const afterEnd = content.slice(endIndex + AUTO_GEN_END.length);
    const userSectionStart = afterEnd.indexOf(USER_EDITABLE_COMMENT);

    if (userSectionStart === -1) return '';

    return afterEnd.slice(userSectionStart + USER_EDITABLE_COMMENT.length);
  }

  /**
   * Generate index file for a server
   */
  generateServerIndex(serverName: string, toolNames: string[], outputDir: string): string {
    const indexPath = path.join(outputDir, serverName, 'index.ts');

    const exports = toolNames
      .map(toolName => `export * as ${toCamelCase(toolName)} from "./${toolName}";`)
      .join('\n');

    const content = `// Auto-generated server index for ${serverName}\n\n${exports}\n`;

    this.ensureDir(path.dirname(indexPath));
    fs.writeFileSync(indexPath, content, 'utf-8');

    return indexPath;
  }

  private ensureDir(dir: string): void {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
  }
}
