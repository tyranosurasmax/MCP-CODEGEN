# Architecture: Universal Code Generation

## Vision

**One tool to generate type-safe wrappers for ANY API, service, or tool.**

Transform API specifications into TypeScript wrappers with 98% token reduction.

---

## The Problem

LLMs struggle with:
- **MCP tool definitions** consuming thousands of tokens
- **REST API docs** (OpenAPI specs) being even larger
- **GraphQL schemas** bloating context windows
- **Database schemas** requiring verbose definitions
- Every integration type having different formats

**Result:** Limited context, higher costs, slower performance.

---

## The Solution

### Universal Code Mode

```
┌────────────────────────────┐
│     Any API Source         │
│  MCP | REST | GraphQL | DB │
└────────────┬───────────────┘
             │
      ┌──────▼────────┐
      │   Universal   │
      │    Adapter    │  ← Source-specific logic
      │    Pattern    │
      └──────┬────────┘
             │
      ┌──────▼────────┐
      │   Discovery   │  ← Extract tool/endpoint definitions
      └──────┬────────┘
             │
      ┌──────▼────────┐
      │   Codegen     │  ← JSON Schema → TypeScript
      └──────┬────────┘
             │
      ┌──────▼────────┐
      │  TypeScript   │  ← Type-safe wrappers
      │   Wrappers    │
      └──────┬────────┘
             │
      ┌──────▼────────┐
      │   Universal   │  ← One runtime for all sources
      │    Runtime    │
      └───────────────┘
```

---

## Design Principles

### 1. **Source Agnostic**
Every source type (MCP, OpenAPI, GraphQL, etc.) implements the same `SourceAdapter` interface.

### 2. **Adapter Pattern**
Easy to add new sources without changing core logic.

### 3. **Unified Output**
All sources generate the same TypeScript wrapper pattern.

### 4. **Single Runtime**
One runtime handles all sources transparently.

### 5. **Token Optimized**
98% reduction across all source types.

---

## Core Components

### Source Adapter Interface

```typescript
interface SourceAdapter {
  name: string;        // Unique identifier
  type: string;        // Source type (mcp, openapi, etc.)

  discover(): Promise<ToolDefinition[]>;  // Find tools/endpoints
  execute(tool: string, params: any): Promise<any>;  // Call tool
  validate(): Promise<boolean>;  // Check configuration
  close(): Promise<void>;  // Cleanup
}
```

Every source type implements this interface, ensuring consistency.

### Current Adapters

#### DONE **MCPAdapter**
- Connects to MCP servers via stdio
- Manages subprocess lifecycle
- Handles retries and timeouts
- Buffers streaming responses (v1.1)

#### DONE **OpenAPIAdapter**
- Loads OpenAPI 3.x specifications
- Converts operations to tool definitions
- Handles HTTP authentication (Bearer, API Key, Basic)
- Makes REST API calls via axios

#### PLANNED **GraphQLAdapter** (Planned v1.2)
- Introspects GraphQL schemas
- Converts queries/mutations to tools
- Handles GraphQL-specific auth
- Executes operations

#### PLANNED **DatabaseAdapter** (Planned v1.2)
- Introspects database schemas
- Generates type-safe CRUD operations
- Supports PostgreSQL, MySQL, SQLite
- Connection pooling

---

## Data Flow

### Discovery Phase

```
1. Load configuration (codegen.config.json)
2. Create adapters for each source
3. Call adapter.discover() for each
4. Normalize to ToolDefinition format
5. Generate TypeScript wrappers
6. Generate per-source index files
```

### Runtime Phase

```
1. Load universal runtime
2. Register all adapters
3. Agent calls: runtime.call("source__tool", params)
4. Runtime routes to correct adapter
5. Adapter executes and returns result
6. Result passed back to agent
```

---

## Configuration Format

### Universal Config

```json
{
  "sources": {
    "mcp": {
      "filesystem": {
        "type": "mcp",
        "command": "npx",
        "args": ["-y", "@modelcontextprotocol/server-filesystem", "/tmp"]
      }
    },
    "openapi": {
      "github": {
        "type": "openapi",
        "spec": "https://api.github.com/openapi.json",
        "baseUrl": "https://api.github.com",
        "auth": {
          "type": "bearer",
          "token": "${GITHUB_TOKEN}"
        }
      }
    }
  },
  "outputDir": "./codegen",
  "runtimePackage": "codegen/runtime"
}
```

---

## Generated Output Structure

```
codegen/
├── mcp/                    # MCP-sourced wrappers
│   ├── filesystem/
│   │   ├── readFile.ts
│   │   ├── writeFile.ts
│   │   └── index.ts
│   └── sqlite/
│       ├── query.ts
│       └── index.ts
├── openapi/                # REST API wrappers
│   ├── github/
│   │   ├── getUser.ts
│   │   ├── listRepos.ts
│   │   └── index.ts
│   └── stripe/
│       ├── createCharge.ts
│       └── index.ts
├── runtime/
│   └── index.ts           # Universal runtime
├── config.json            # Saved configuration
├── benchmark.json         # Token usage stats
└── BENCHMARK.md          # Human-readable report
```

---

## Wrapper Format

Every generated wrapper follows this pattern:

```typescript
// AUTO-GENERATED BY codegen v1.1.0
// hash: abc123

import { call } from "codegen/runtime";

export interface Params { /* ... */ }
export interface Result { /* ... */ }

export const toolMeta = {
  source: "github",
  type: "openapi",
  name: "get_user",
  description: "Get a user by username"
};

export async function getUser(params: Params): Promise<Result> {
  return call<Params, Result>("github__get_user", params);
}

// END AUTO-GENERATED

/* USER-EDITABLE AREA BELOW */
// Add custom logic here...
```

---

## Extension Points

### Adding a New Source Type

1. **Create Adapter Class**
```typescript
export class MyAdapter extends BaseAdapter {
  constructor(name: string, config: MyConfig) {
    super(name, 'my-source-type');
  }

  async discover() { /* Fetch tool definitions */ }
  async execute(tool, params) { /* Execute tool */ }
}
```

2. **Add to Orchestrator**
```typescript
if (config.sources.mySource) {
  for (const [name, cfg] of Object.entries(config.sources.mySource)) {
    adapters.push(new MyAdapter(name, cfg));
  }
}
```

3. **Update Types**
```typescript
export interface MySourceConfig {
  type: 'my-source-type';
  // ... config fields
}

export interface UniversalConfig {
  sources: {
    mcp?: { [name: string]: MCPServerConfig };
    openapi?: { [name: string]: OpenAPIConfig };
    mySource?: { [name: string]: MySourceConfig };  // Add this
  };
}
```

That's it! The rest (codegen, runtime, CLI) works automatically.

---

## Performance Characteristics

### Token Reduction

| Source Type | Before (raw spec) | After (wrappers) | Reduction |
|-------------|------------------|------------------|-----------|
| MCP Server  | ~152,000 tokens  | ~2,000 tokens    | **98.7%** |
| OpenAPI     | ~200,000 tokens  | ~3,000 tokens    | **98.5%** |
| GraphQL     | ~100,000 tokens  | ~1,500 tokens    | **98.5%** (estimated) |

### Runtime Performance

- **MCP**: Persistent subprocess connections
- **REST**: HTTP connection pooling via axios
- **GraphQL**: Single endpoint, batched queries
- **Database**: Connection pooling

---

## Security Model

### Current (v1.1)

- **MCP**: Subprocess isolation (limited)
- **REST**: API keys via environment variables
- **No sandboxing**: Generated code runs with full privileges

### Planned (v1.2+)

- **Sandboxing**: VM2 or isolated-vm for Node.js
- **Credential Management**: Vault integration, secret rotation
- **Network Policies**: Allowlist/blocklist for HTTP
- **Audit Logging**: Track all tool executions

---

## Future Roadmap

### v1.2 - Multi-Source Maturity
- GraphQL adapter
- Database adapter
- State management
- Enhanced security

### v1.3 - Advanced Features
- Streaming support
- Caching layer
- Rate limiting
- Circuit breakers

### v2.0 - Platform
- Web UI for configuration
- Plugin ecosystem
- Commercial enterprise features
- Multi-language support (Python, Go)

### v3.0 - Intelligence
- AI-powered composition
- Automatic error recovery
- Cost optimization
- Performance prediction

---

## Comparison to Alternatives

### vs. Anthropic's Code Mode (MCP only)
- DONE We support more source types
- DONE Open source
- DONE Platform agnostic
- NOTE They have better security (sandboxing)

### vs. Cloudflare's Code Mode
- DONE We're not platform-locked
- DONE We support more sources
- DONE Simpler architecture
- NOTE They have Workers isolation

### vs. OpenAPI Generator
- DONE We optimize for LLM context (98% reduction)
- DONE We support multiple source types
- NOTE They have more mature codegen

### vs. Prisma (Databases)
- DONE We support multiple source types
- NOTE They have better DB features
- NOTE They have migrations

**Our Advantage:** Universal approach with LLM optimization.

---

## Technical Decisions

### Why TypeScript First?
- Best LLM training data
- Strong typing helps agents
- Great tooling (VSCode)
- Easy to add other languages later

### Why Adapter Pattern?
- Extensibility without coupling
- Easy to test in isolation
- Clear separation of concerns
- Community can add adapters

### Why Single Runtime?
- Simpler for agents
- Consistent error handling
- Easier to add features (caching, logging)
- Clear ownership of connections

### Why Not Full Streaming Yet?
- Complexity vs. value tradeoff
- Most tools return small payloads
- Coming in v1.2 when it's critical

---

## Contributing

See [CONTRIBUTING.md](./CONTRIBUTING.md) for:
- Development setup
- Architecture guidelines
- How to add adapters
- Testing strategies

---

**Built with the belief that AI agents deserve infrastructure as good as the APIs they call.**
